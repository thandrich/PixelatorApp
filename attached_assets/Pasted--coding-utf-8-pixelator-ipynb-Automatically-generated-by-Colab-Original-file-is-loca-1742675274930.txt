# -*- coding: utf-8 -*-
"""pixelator.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1t7YwrruX-L3sT-jklmZ4AkBlGeyYLeMw
"""

from PIL import Image
from skimage import color, feature, filters, io
from sklearn.cluster import KMeans
import itertools
import imageio
import ntpath
import numpy as np
import os

def downscale_image(image_path, max_resolution=(256, 256)):
    """
    Downscales an image to a maximum resolution while maintaining aspect ratio.

    Args:
        image_path: The path to the image file.
        max_resolution: A tuple representing the maximum width and height
                        of the downscaled image (default: (600, 600)).

    Returns:
        A PIL Image object representing the downscaled image.
    """
    img = Image.open(image_path)
    width, height = img.size

    # Calculate new dimensions based on aspect ratio
    if width > height:
        new_width = max_resolution[0]
        new_height = int(height * (new_width / width))
    else:
        new_height = max_resolution[1]
        new_width = int(width * (new_height / height))

    # Resize the image
    resized_img = img.resize((new_width, new_height), Image.Resampling.LANCZOS)

    return resized_img

def enhance_contrast(image):

    # Convert PIL image to RGB NumPy array
    image_rgb = np.array(image)

    # Example: Simple contrast stretching
    p2, p98 = np.percentile(image_rgb, (2, 98))
    enhanced_image = np.clip((image_rgb - p2) / (p98 - p2) * 255, 0, 255).astype(np.uint8)
    return enhanced_image

def hex_to_rgb(hex_color):
    return tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))

def quantize_to_palette_cielab(image, palette_path):
    try:
        image_rgb = np.array(image) / 255.0  # Normalize to 0.0-1.0
        with open(palette_path, 'r') as f:
            palette_hex = [line.strip() for line in f]
        palette_rgb = np.array([hex_to_rgb(hex_code) for hex_code in palette_hex]) / 255.0 #normalize palette as well
        palette_lab = color.rgb2lab(palette_rgb)

        image_lab = color.rgb2lab(image_rgb)

        quantized_image_float = np.zeros_like(image_rgb)
        for y in range(image_rgb.shape[0]):
            for x in range(image_rgb.shape[1]):
                distances = np.linalg.norm(palette_lab - image_lab[y, x], axis=1)
                closest_index = np.argmin(distances)
                quantized_image_float[y, x] = palette_rgb[closest_index]

        quantized_image = (quantized_image_float * 255).astype(np.uint8) #convert back to uint8
        return quantized_image
    except FileNotFoundError:
        print(f"Error: File not found: {palette_path}")
        return None
    except Exception as e:
        print(f"An unexpected error occurred during quantization: {e}")
        return None

def quantize_with_edge_emphasis(image, palette_path):
    try:
        image_rgb = np.array(image) / 255.0
        with open(palette_path, 'r') as f:
            palette_hex = [line.strip() for line in f]
        palette_rgb = np.array([hex_to_rgb(hex_code) for hex_code in palette_hex]) / 255.0
        palette_lab = color.rgb2lab(palette_rgb)

        gray_image = color.rgb2gray(image_rgb)
        edges = feature.canny(gray_image)

        image_lab = color.rgb2lab(image_rgb)

        quantized_image_float = np.zeros_like(image_rgb)
        for y in range(image_rgb.shape[0]):
            for x in range(image_rgb.shape[1]):
                distances = np.linalg.norm(palette_lab - image_lab[y, x], axis=1)
                closest_index = np.argmin(distances)
                quantized_image_float[y, x] = palette_rgb[closest_index]

        quantized_image = (quantized_image_float * 255).astype(np.uint8)
        return quantized_image
    except FileNotFoundError:
        print(f"Error: File not found: {palette_path}")
        return None
    except Exception as e:
        print(f"An unexpected error occurred during quantization: {e}")
        return None

def quantize_kmeans(image, palette_path):
    """Quantizes an image using k-means clustering and closest palette color matching."""
    try:
        image_rgb = np.array(image).reshape((-1, 3)) / 255.0

        with open(palette_path, 'r') as f:
            palette_hex = [line.strip() for line in f]
        num_colors = len(palette_hex)
        palette_rgb = np.array([hex_to_rgb(hex_code) for hex_code in palette_hex]) / 255.0
        palette_lab = color.rgb2lab(palette_rgb)

        kmeans = KMeans(n_clusters=num_colors, random_state=0, n_init='auto')
        kmeans.fit(image_rgb)
        labels = kmeans.predict(image_rgb)

        cluster_means = kmeans.cluster_centers_
        cluster_lab = color.rgb2lab(cluster_means)

        # Assign each cluster to the closest palette color
        quantized_pixels = np.zeros_like(image_rgb)
        for i, cluster_center in enumerate(cluster_lab):
            distances = np.linalg.norm(palette_lab - cluster_center, axis=1)
            closest_palette_index = np.argmin(distances)
            quantized_pixels[labels == i] = palette_rgb[closest_palette_index]

        quantized_image = (quantized_pixels.reshape(image.size[1], image.size[0], 3) * 255).astype(np.uint8)
        return quantized_image

    except FileNotFoundError:
        print(f"Error: Palette file not found: {palette_path}")
        return None
    except ValueError as e:
        print(f"ValueError during k-means or color processing: {e}")
        return None
    except Exception as e:
        print(f"An unexpected error occurred during k-means quantization: {e}")
        return None

def quantize_kmeans_full(image, palette_path):
    """Quantizes an image using k-means and brightness-based palette mapping."""
    try:
        image_rgb = np.array(image).reshape((-1, 3)) / 255.0

        with open(palette_path, 'r') as f:
            palette_hex = [line.strip() for line in f]
        num_colors = len(palette_hex)
        palette_rgb = np.array([hex_to_rgb(hex_code) for hex_code in palette_hex]) / 255.0

        kmeans = KMeans(n_clusters=num_colors, random_state=0, n_init='auto')
        kmeans.fit(image_rgb)
        labels = kmeans.predict(image_rgb)

        cluster_means = kmeans.cluster_centers_

        cluster_brightness = np.sum(cluster_means, axis=1)
        palette_brightness = np.sum(palette_rgb, axis=1)

        cluster_order = np.argsort(cluster_brightness)
        palette_order = np.argsort(palette_brightness)

        quantized_pixels = np.zeros_like(image_rgb)
        for cluster_index, palette_index in zip(cluster_order, palette_order):
            quantized_pixels[labels == cluster_index] = palette_rgb[palette_index]

        quantized_image = (quantized_pixels.reshape(image.size[1], image.size[0], 3) * 255).astype(np.uint8)
        return quantized_image

    except FileNotFoundError:
        print(f"Error: Palette file not found: {palette_path}")
        return None
    except ValueError as e:
        print(f"ValueError during k-means or color processing: {e}")
        return None
    except Exception as e:
        print(f"An unexpected error occurred during k-means quantization: {e}")
        return None

def upscale_image(image, scale_factor):
    """Upscales an image by repeating pixels."""
    if not 2 <= scale_factor <= 20:
        raise ValueError("Scale factor must be between 2 and 20.")

    img = Image.fromarray(image) # Convert numpy array to PIL image

    width, height = img.size
    new_width = width * scale_factor
    new_height = height * scale_factor

    upscaled_img = img.resize((new_width, new_height), Image.Resampling.NEAREST) #use nearest neighbour for pixel art upscaling

    return np.array(upscaled_img) #return numpy array

def verify_colors(image, palette_rgb):
    """Verifies that all colors in the image are present in the palette."""
    image_colors = np.unique(image.reshape((-1, 3)), axis=0)
    for color in image_colors:
        if not any(np.array_equal(color, palette_color) for palette_color in palette_rgb):
            print(f"Color {color} is not in the palette!")
            return False  # Found a color not in the palette
    return True  # All colors are in the palette

def execute(input_folder=os.getcwd(), output_folder=os.path.join(os.getcwd(), "output"),
            palette_path=os.path.join(os.getcwd(), "palette/resurrect-64.hex"), max_resolution=(256, 256),
            quantization_mode="contrast", upscale_factor=1):
    """Processes images with specified quantization mode, upscaling, and names output files accordingly."""

    os.makedirs(output_folder, exist_ok=True)

    for filename in os.listdir(input_folder):
        if filename.endswith((".jpg", ".jpeg", ".png", ".bmp")):
            input_path = os.path.join(input_folder, filename)
            name, ext = os.path.splitext(filename)

            try:
                resized_image = downscale_image(input_path, max_resolution)

                if quantization_mode == "contrast":
                    enhanced_image = enhance_contrast(resized_image)
                    quantized_image = quantize_with_edge_emphasis(enhanced_image, palette_path)
                    output_filename = f"{name}_contrast"
                elif quantization_mode == "natural":
                    quantized_image = quantize_to_palette_cielab(resized_image, palette_path)
                    output_filename = f"{name}_natural"
                elif quantization_mode == "kmeans":
                    quantized_image = quantize_kmeans(resized_image, palette_path)
                    output_filename = f"{name}_kmeans"
                elif quantization_mode == "kmeans_brightness":  # New case for k-means brightness
                    quantized_image = quantize_kmeans_brightness(resized_image, palette_path)
                    output_filename = f"{name}_kmeans_brightness" #correct output name
                else:
                    print(f"Invalid quantization mode: {quantization_mode}. Skipping {filename}.")
                    continue

                if quantized_image is not None:
                    with open(palette_path, 'r') as f:
                        palette_hex = [line.strip() for line in f]
                    palette_rgb = np.array([hex_to_rgb(hex_code) for hex_code in palette_hex])
                    if verify_colors(quantized_image, palette_rgb): #verification prior to scaling
                        print("All colors in the image are from the palette.")
                    else:
                        print("WARNING: Image contains colors not in the palette!")

                    if upscale_factor != 1:
                        quantized_image = upscale_image(quantized_image, upscale_factor)
                        output_filename += f"_{upscale_factor}x"

                    output_filename += ".png"
                    output_path = os.path.join(output_folder, output_filename)
                    imageio.imwrite(output_path, quantized_image)
                    print(f"Quantized and saved: {output_path}")

                else:
                    print(f"Quantization failed for {filename}. Skipping.")

            except Exception as e:
                print(f"Error processing {filename}: {e}")

def execute(input_folder=os.getcwd(), output_folder=os.path.join(os.getcwd(), "output"),
            palette_paths=[os.path.join(os.getcwd(), "palette/resurrect-64.hex")], max_resolution=(256, 256),
            quantization_modes=["contrast"], upscale_factor=1, verify=False):
    """Processes images with multiple quantization modes and palettes."""

    os.makedirs(output_folder, exist_ok=True)

    for filename in os.listdir(input_folder):
        if filename.endswith((".jpg", ".jpeg", ".png", ".bmp")):
            input_path = os.path.join(input_folder, filename)
            name, ext = os.path.splitext(filename)

            try:
                resized_image = downscale_image(input_path, max_resolution)

                for palette_path in palette_paths: #iterate over palettes
                    palette_name = os.path.splitext(ntpath.basename(palette_path))[0]

                    for quantization_mode in quantization_modes: #iterate over quantisation modes
                        try:
                            if quantization_mode == "contrast":
                                enhanced_image = enhance_contrast(resized_image)
                                quantized_image = quantize_with_edge_emphasis(enhanced_image, palette_path)
                                output_filename = f"{name}_contrast_{palette_name}"
                            elif quantization_mode == "natural":
                                quantized_image = quantize_to_palette_cielab(resized_image, palette_path)
                                output_filename = f"{name}_natural_{palette_name}"
                            elif quantization_mode == "kmeans":
                                quantized_image = quantize_kmeans(resized_image, palette_path)
                                output_filename = f"{name}_kmeans_{palette_name}"
                            elif quantization_mode == "kmeans_full":
                                quantized_image = quantize_kmeans_full(resized_image, palette_path)
                                output_filename = f"{name}_kmeans_full_{palette_name}"
                            else:
                                print(f"Invalid quantization mode: {quantization_mode}. Skipping.")
                                continue #skip to next quantisation mode

                            if quantized_image is not None:
                                if verify:
                                    with open(palette_path, 'r') as f:
                                        palette_hex = [line.strip() for line in f]
                                    palette_rgb = np.array([hex_to_rgb(hex_code) for hex_code in palette_hex])
                                    if verify_colors(quantized_image, palette_rgb):
                                        print(f"All colors in the image are from the palette {palette_name}.")
                                    else:
                                        print(f"WARNING: Image contains colors not in the palette {palette_name}!")

                                if upscale_factor != 1:
                                    quantized_image = upscale_image(quantized_image, upscale_factor)
                                    output_filename += f"_{upscale_factor}x"

                                output_filename += ".png"
                                output_path = os.path.join(output_folder, output_filename)
                                imageio.imwrite(output_path, quantized_image)
                                print(f"Quantized and saved: {output_path}")

                            else:
                                print(f"Quantization failed for {filename} with mode {quantization_mode} and palette {palette_name}. Skipping.")

                        except Exception as e:
                            print(f"Error processing {filename} with mode {quantization_mode} and palette {palette_name}: {e}")

            except Exception as e:
                print(f"Error processing {filename}: {e}")

execute(quantization_modes=["kmeans"],
        palette_paths=["antiquity16.hex", "go-line.hex", "dawnbringer-16.hex", "test2.hex"],
        max_resolution=(256,256),
        upscale_factor=4)

"""## Setup
  - Copy this notebook to make your own editable version
  - upload your images into the root folder of the files section to the left <--
  - create a new file also in the root folder called resurrect-64.hex
  - save the list of hex colour codes below into that file (it's only to
  carry the codes as one per line, no quotation marks)
  - run all cells from top to bottom (all cells but the last one are just setting up,
  so you can rerun the last without re-running all)


## Instructions
- there are 4 quantisation methods (read approaches to map the original colour into the new colour space) natural, contrast, kmeans, kmeans_full
  - **natural**: closest match
  - **contrast**: closest match after increasing the contrast
  - **kmeans**: closest match after reducing the original space to the number of colours in the target space
  - **kmeans_full**: reducing the number of colours in the original space to match to number of colours in target space and assigning 1:1 based on relative bightness
- you can specify multiple quantisation methods at the same time to create multiple outputs
- the same is true for the target colour spaces / palettes but you would need to create them first (like the one below) as hex files in the folder
  - [lospec](https://lospec.com/) has a nice selection
- the max resolution limits the amount of pixels in the output
- the upscale factor arteficially in inflates the final resolution to end up with images that are not just tiny; though depending on the software the viewer will do the same without backing it into the file

Have fun!
"""

2e222f
3e3546
625565
966c6c
ab947a
694f62
7f708a
9babb2
c7dcd0
ffffff
6e2727
b33831
ea4f36
f57d4a
ae2334
e83b3b
fb6b1d
f79617
f9c22b
7a3045
9e4539
cd683d
e6904e
fbb954
4c3e24
676633
a2a947
d5e04b
fbff86
165a4c
239063
1ebc73
91db69
cddf6c
313638
374e4a
547e64
92a984
b2ba90
0b5e65
0b8a8f
0eaf9b
30e1b9
8ff8e2
323353
484a77
4d65b4
4d9be6
8fd3ff
45293f
6b3e75
905ea9
a884f3
eaaded
753c54
a24b6f
cf657f
ed8099
831c5d
c32454
f04f78
f68181
fca790
fdcbb0

#helper to discard output folder
import shutil

shutil.rmtree('output')

